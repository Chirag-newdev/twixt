===== begin.h =====
#ifndef B_H
#define B_H
#include "var.h"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define RESET   "\033[0m"
void initialize();
#endif

===== block.h =====
#ifndef BLOCK_H
#define BLOCK_H
#include "var.h"
void block(int x,int y,int dx,int dy);
#endif

===== check.h =====
#ifndef CHECK_H
#define CHECK_H
#include "block.h"
bool check(int x,int y,int dx,int dy);
#endif

===== depn.h =====
#ifndef P_H
#define P_H
#include "var.h"
#include "print.h"
#include "move.h"
#include "display.h"
#include "link.h"
#include "begin.h"
#include "wincheck.h"
#endif

===== display.h =====
#ifndef D_H
#define D_H
#include "print.h"
void display();
#endif

===== link.h =====
#ifndef link_H
#define link_H
#include "check.h"
#include "wincheck.h"
void link(int x,int y);
#endif

===== move.h =====
#ifndef M_H
#define M_H
#include "var.h"
int pin(char z,int flag);
#endif

===== print.h =====
#ifndef printrow_H
#define printrow_H
#include "var.h"
void print(char*s);
#endif

===== var.h =====
#ifndef Gl_H
#define Gl_H
#define SIZE 24 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <stdbool.h>
extern char arr[SIZE][SIZE];
extern bool state[SIZE+5][SIZE+5];
extern char connected[SIZE][SIZE];
extern char links[SIZE][SIZE][8];
#endif

===== wincheck.h =====
#ifndef WCK_H
#define WCK_H
#include "var.h"
bool win();
int update(int,int);
#endif

===== begin.c =====
#include "begin.h"

void initialize()
{
    printf(GREEN
        "  _________    _____  _____      _____      ____  ____    _________   \n"
        " |  _   _  |  |_   _||_   _|    |_   _|    |_  _||_  _|  |  _   _  |  \n"
        " |_/ | | \\_|    | | /\\ | |        | |        \\ \\  / /    |_/ | | \\_|  \n"
        "     | |        | |/  \\| |        | |         > `' <         | |      \n"
        "    _| |_       |   /\\   |       _| |_      _/ /'`\\ \\_      _| |_     \n"
        "   |_____|      |__/  \\__|      |_____|    |____||____|    |_____|    \n"
        RESET
        );

    printf("\n");
    printf("Player O: Connect " RED "TOP" RESET " to " BLUE "BOTTOM" RESET "\n");
    printf("Player X: Connect " GREEN "LEFT" RESET " to " MAGENTA "RIGHT" RESET "\n\n");

    printf("Rules:\n");
    printf(" - Enter moves on one line: row column\n");
    printf(" - Do not press Enter between row and column\n");
    printf(" - Out-of-range or occupied moves are rejected\n");
    printf(" - Links update automatically after every valid move\n");
    printf(" - Maximum 250 moves this phase\n\n");
    printf("\033[1;33m"" - ANY INPUT AFTER 2 NUMBERS \033[33mi.e. (1 2 3..) etc will be truncated\n\n\033[0m");
    printf("Player O goes first\n");
    printf("Press Enter to begin\n ");
    char x[1024];
    fgets(x,1024,stdin);
    return;
}

===== block.c =====
#include "block.h"
void block(int x,int y,int dx,int dy)
{
    if(abs(dx)==1)
        state[x+(dx>0)][y+(dy>0)]  =  state[x+(dx>0)][y+(dy>0)+dy/2]  =  1;
    else if(abs(dx)==2)
        state[x+(dx>0)-(dx<0)][y+(dy>0)]  =  state[x+(dx>0)*dx][y+(dy>0)]  =  1;
    return;
}

===== check.c =====
#include "check.h"
bool check(int x,int y,int dx,int dy)
{
    if(abs(dx)==1)
        {
            if(state[x+(dx>0)][y+(dy>0)] || state[x+(dx>0)][y+(dy>0)+dy/2])
            {
                return 0;
            }
        }
    else if(abs(dx)==2)
    {
        if(state[x+(dx>0)-(dx<0)][y+(dy>0)] || state[x+(dx>0)*dx][y+(dy>0)])
        {
            return 0;
        }
    }
    block(x, y, dx, dy);
    return true;
}

===== display.c =====
#include "var.h"
#define H "\033[1B\033[1D"
#include "display.h"
void display()
{
    system("cls");
    printf("   ");
    for(int i=0;i<SIZE;i++)printf("%d%s",i,i<10?"   ":"  ");
    arr[0][0]=arr[0][SIZE-1]=arr[SIZE-1][0]=arr[SIZE-1][SIZE-1]=' ';
    printf("\n");
    for (int i = 0; i < SIZE; i++)
    {
        printf("%d%s",i,i<10?"  ":" ");
        print(arr[i]);
        printf("\n\n");
    }
    printf("\033[31m\0337\033[%d;%dH-------------------------------------------------------------------------------------\0338\033[0m",3,8);
    printf("\033[31m\0337\033[%d;%dH-------------------------------------------------------------------------------------\0338\033[0m",47,8);
    printf("\033[34m\0337\033[%d;%dH"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|""\0338\033[0m",3,7);
    printf("\033[34m\0337\033[%d;%dH"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|"H"|""\0338\033[0m",3,95);
    return;
}

===== link.c =====
#include "link.h"
#define tw "\n\033[1B\033[1D"
#define kw "\033[1B\033[1D"
void link(int x,int y)
{
    int a[8][2]={{x-2,y+1},{x-1,y+2},{x+1,y+2},{x+2,y+1},{x+2,y-1},{x+1,y-2},{x-1,y-2},{x-2,y-1}};
    for(int i=0;i<8;i++)
    {
        int x1=a[i][0];
        int y1=a[i][1];
        int dx=x1-x,dy=y1-y;
        char z= dx*dy>0?'\\':'/';
        if((x1<0||x1>=SIZE) || (y1<0||y1>=SIZE))continue;
        if(arr[x][y]!=arr[x1][y1])continue;
        if(!check(x,y,dx,dy))continue;
        if(abs(dx)==1)
        {
            printf("\0337");
            printf("\033[%d;%dH", (x+x1)+2,1+(y+y1)*2);
            printf("%c-----%c",z,z);
            fflush(stdout);
            printf("\0338");
        }
        else
        {
            printf("\0337");
            printf("\033[%d;%dH", (x+x1),4+(y+y1)*2);
            printf(kw" %c"kw"|"kw"%c",z,z);
            fflush(stdout);
            printf("\0338");
        }
        links[x][y][i]=1;
        links[x1][y1][(i+4)%8]=1;
    }
    update(x,y);
    return;
}

===== main.c =====
#include "depn.h"
char arr[SIZE][SIZE]={0};
bool state[SIZE+5][SIZE+5]={false};
char connected[SIZE][SIZE]={0};
char links[SIZE][SIZE][8]={0};
int main()
{
    memset(arr,'.',sizeof(arr));
    memset(state,0,sizeof(state));
    bool x=0;
    int i=240;
    initialize();
    display();
    while(i--)
    {
        int t=0;
        while(t<=0)
        {
            t=pin(x?'X':'O',t);
            if(t==-10)return 0;
        }
        x=!x;
        link(t/SIZE,t%SIZE);
        if(win())break;
    }
    return 0;
}

===== move.c =====
#include "move.h"
int sanitizer(int *x, int *y)
{
    char buf[1024];
    if (!fgets(buf, sizeof buf, stdin)) 
    {
        return 1;
    }
    if (!strchr(buf, '\n'))
    {
        int ch;
        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }
    char *p = buf;
    char *end;
    while (isspace((unsigned char)*p))
        p++;
    if (*p == '\0' || *p == '\n')
        return 3;
    long a = strtol(p, &end, 10);
    if (p == end)return 3;
    *x = (int)a;
    p = end;
    long b = strtol(p, &end, 10);
    if (p == end)return 3;
    *y = (int)b;
    return 0;
}
int pin(char z, int flag)
{
    int x, y;
    printf("%sPlayer %c, enter row and column :",flag == -2 ? "" : "                ", z);
    fflush(stdout);
    if (sanitizer(&x, &y) != 0)
    {
        printf("\033[1A\033[2K\033[33m[invalid input]\033[0m ");
        fflush(stdout);
        return -2;
    }

    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE)
    {
        printf("\033[1A\033[2K\033[33m[out of bounds]\033[0m ");
        fflush(stdout);
        return -2;
    }
    if (z == 'O' && (y == 0 || y == SIZE - 1))
    {
        printf("\033[1A\033[2K\033[33m[invalid move]\033[0m  ");
        fflush(stdout);
        return -2;
    }
    if (z == 'X' && (x == 0 || x == SIZE - 1))
    {
        printf("\033[1A\033[2K\033[33m[invalid move]\033[0m  ");
        fflush(stdout);
        return -2;
    }
    if (arr[x][y] != '.')
    {
        printf("\033[1A\033[2K\033[33m[occupied]\033[0m      ");
        fflush(stdout);
        return -2;
    }
    arr[x][y] = z;
    printf("\033[s");
    printf("\033[r\033[H");
    printf("\033[%d;%dH", 2 * x + 2, 4 + y * 4);
    if (z == 'O')printf("\033[31mO\033[0m");
    else printf("\033[34mX\033[0m");
    fflush(stdout);
    printf("\033[u");
    printf("\033[%dA", flag == 0 ? 0 : flag == -2 ? 1 : 2);
    fflush(stdout);
    return x * SIZE + y;
}

===== print.c =====
#include "print.h"
void print(char* s)
{
    for(int i=0;i<SIZE-1;i++)
    {
        printf("%c   ",s[i]);
    }
    printf("%c",s[SIZE-1]);
    return;
}

===== wincheck.c =====
#include "wincheck.h"
bool win()
{
    for(int i=1;i<SIZE-1;i++)
    {
        if(connected[i][SIZE-1]==-1)printf("PLAYER: X HAS WON\n\n CONGRATS \n\nexiting...");
        else if(connected[SIZE-1][i]==1)printf("PLAYER: O HAS WON\n\n CONGRATS \n\nexiting...");
        else continue;
        return 1;
    }
    return 0;
}
int update(int x,int y)
{
    int a[8][2]={{x-2,y+1},{x-1,y+2},{x+1,y+2},{x+2,y+1},{x+2,y-1},{x+1,y-2},{x-1,y-2},{x-2,y-1}};
    if(connected[x][y]==0)
    {
        if(x==0)connected[x][y]=1;
        else if(y==0)connected[x][y]=-1;
        else for (int i = 0; i < 8; i++)
        {
            int x1=a[i][0];
            int y1=a[i][1];
            if((x1<0||x1>=SIZE) || (y1<0||y1>=SIZE))continue;
            else if(connected[x1][y1]!=0 && links[x][y][i]==1)
            {
                connected[x][y]=connected[x1][y1];
                break;
            }
        }
    }
    for (int i = 0; i < 8; i++)
    {
        if(connected[x][y]==0)continue;
        int x1=a[i][0];
        int y1=a[i][1];
        if((x1<0||x1>=SIZE) || (y1<0||y1>=SIZE))continue;
        if(connected[x1][y1]==0 && links[x][y][i]==1)update(x1,y1);
    }
    return 0;        
}

===== working.c =====
// #include <stdio.h>
// #include <stdlib.h>
// #include <stdbool.h>
// #include <math.h>
// #include <string.h>
// #include <windows.h>
// #define RED     "\033[31m"
// #define GREEN   "\033[32m"
// #define YELLOW  "\033[33m"
// #define BLUE    "\033[34m"
// #define MAGENTA "\033[35m"
// #define RESET   "\033[0m"
// #define SIZE 24 
// #define tw "\n\033[1B\033[1D"
// #define kw "\033[1B\033[1D"
// char arr[SIZE][SIZE]={0};
// bool state[SIZE+1][SIZE+1]={0};
// void init()
// {
//         printf(GREEN
//         "  _________    _____  _____      _____      ____  ____    _________   \n"
//         " |  _   _  |  |_   _||_   _|    |_   _|    |_  _||_  _|  |  _   _  |  \n"
//         " |_/ | | \\_|    | | /\\ | |        | |        \\ \\  / /    |_/ | | \\_|  \n"
//         "     | |        | |/  \\| |        | |         > `' <         | |      \n"
//         "    _| |_       |   /\\   |       _| |_      _/ /'`\\ \\_      _| |_     \n"
//         "   |_____|      |__/  \\__|      |_____|    |____||____|    |_____|    \n"RESET
//     );
//     printf("\n");
//     printf("Player \033[1;94mO\033[0m: Connect " RED "LEFT" RESET " to " BLUE "RIGHT" RESET "\n");
//     printf("Player \033[1;94mX\033[0m: Connect " GREEN "TOP" RESET " to " MAGENTA "BOTTOM" RESET "\n");
//     printf("\n\nPlayer \033[1;94mO\033[0m goes first\npress Enter to begin the game\n ");
//     getchar();
//     char(*ptr)[] = arr;
//     memset(arr,'.',sizeof(arr));
//     return;
// }
// void print(char* s)
// {
//     for(int i=0;i<SIZE-1;i++)
//     {
//         printf("%c   ",s[i]);
//     }
//     printf("%c",s[SIZE-1]);
//     return;
// }
// void display()
// {
//     system("cls");
//     printf("   ");
//     for(int i=0;i<SIZE;i++)printf("%d%s",i,i<10?"   ":"  ");
//     printf("\n");
//     for (int i = 0; i < SIZE; i++)
//     {
//         printf("%d%s",i,i<10?"  ":" ");
//         print(arr[i]);
//         printf("\n\n");
//     }
//     return;
// }
// int pin(char z)
// {
//     int x,y;
//     printf("Player :%c, please enter row and comumn of your move in format:\"row column\"\n\033[2K",z);
//     if(scanf(" %d %d",&x,&y)!=2)return -10;
//     if((x<0||x>=SIZE) || (y<0||y>=SIZE))
//     {
//         printf("\0337");
//         printf("\0338");
//         printf("\033[3A");
//         printf("out of bounds\n");
//         return -2;
//     }
//     if(arr[x][y]=='.')
//     {
//         arr[x][y]=z;
//         printf("\0337");
//         printf("\033[r\033[H");
//         printf("\033[%d;%dH", 2*x+2,4+y*4);
//         printf("%c",z);
//         fflush(stdout);
//         printf("\0338");
//         printf("\033[2A");
//         return (x)*SIZE  +  (y);
//     }
//     else
//     {
//         printf("\033[2A");
//         return -1;
//     }
// }
// void block(int x,int y,int dx,int dy)
// {
//     if(abs(dx)==1)state[x+(dx>0)][y+(dy>0)]=state[x+(dx>0)][y+(dy>0)+dy/2]=1;
//     else if(abs(dx)==2)state[x+(dx>0)-(dx<0)][y+(dy>0)]=state[x+(dx>0)*dx][y+(dy>0)]=1;
//     return;
// }
// bool check(int x,int y,int dx,int dy)
// {
//     if(abs(dx)==1)
//         {
//             if(state[x+(dx>0)][y+(dy>0)] || state[x+(dx>0)][y+(dy>0)+dy/2])
//             {
//                 return 0;
//             }
//         }
//     else if(abs(dx)==2)
//     {
//         if(state[x+(dx>0)-(dx<0)][y+(dy>0)] || state[x+(dx>0)*dx][y+(dy>0)])
//         {
//             return 0;
//         }
//     }
//     block(x, y, dx, dy);
//     return true;
// }
// void viable(int x,int y)
// {
//     char a[8][2]={{x+2,y+1},{x+1,y+2},{x+2,y-1},{x+1,y-2},{x-1,y-2},{x-2,y-1},{x-2,y+1},{x-1,y+2}};
//     for(int i=0;i<8;i++)
//     {
//         char x1=a[i][0];
//         char y1=a[i][1];
//         int dx=x1-x,dy=y1-y;
//         char z= dx*dy>0?'\\':'/';
//         if(arr[x][y]!=arr[x1][y1])continue;
//         if(!check(x,y,dx,dy))continue;
//         if(fabs(dx)==1)
//         {
//             printf("\0337");
//             printf("\033[%d;%dH", (x+x1)+2,1+(y+y1)*2);
//             printf("%c-----%c",z,z);
//             fflush(stdout);
//             printf("\0338");
//         }
//         else
//         {
//             printf("\0337");
//             printf("\033[%d;%dH", (x+x1),4+(y+y1)*2);
//             printf("%c"kw"|"kw"|"kw"|"kw"%c",z,z);
//             fflush(stdout);
//             printf("\0338");
//         }
//     }
//     return;
// }
// int main()
// {
//     init();
//     bool x=0;
//     int i=10;
//     display();
//     while(i--)
//     {
//         int t=-1;
//         while(t==-1)
//         {
//             t=pin(x?'X':'O');
//             if(t==-10)return 0;
//         }
//         x=!x;
//         viable(t/SIZE,t%SIZE);
//     }
//     return 0;
// }

===== Readme.md =====
# TwixT – Phase 1

Turn-based TwixT variant in C. Players place pins, automatically form knight-move links, and win by completing a border-to-border chain.

---

## Objectives
- 24×24 fixed board
- O connects **TOP → BOTTOM**
- X connects **LEFT → RIGHT**
- Links auto-generate on valid knight moves
- Blocked segments prevent link creation
- Connectivity updates after every move
- Win is detected automatically

---

## Rules
- O starts
- Input: `row column`
- Only two integers are read; anything after is ignored
- Out-of-range or occupied positions are rejected
- Corners are not allowed
- O may not play on left/right edges
- X may not play on top/bottom edges
- Max moves: **240**

---

## Win Detection
Each pin propagates connectivity through mutual links:
- O wins on a continuous path from top to bottom
- X wins on a path from left to right

Game ends immediately when either is achieved.

---

## Build (Windows)
Requires `make` and GCC.

```bash
make       # build and run
make clean # remove build files

===== Makefile =====
# ===========================
#  Basic GCC Makefile (Windows + PowerShell)
#  Supports: build, run, debug, clean
# ===========================
# Compiler and flags
CC      = gcc
CFLAGS  = -Wall -Wextra -Wpedantic -g -O0
TARGET  = a.exe

# Source and object files (auto-detects all .c files except working.c)
SRC = $(filter-out working.c, $(wildcard *.c))
OBJ = $(SRC:.c=.o)

# Default target — same as 'make run'
all: run

# Build rule
$(TARGET): $(OBJ)
	$(CC) $(CFLAGS) -o $(TARGET) $(OBJ) $(LDFLAGS)

# Compile each .c into .o
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Run the program in maximized Command Prompt
run: $(TARGET)
	cmd /c start "" /max cmd /k "$(CURDIR)\$(TARGET)"

# Launch GDB in TUI mode for debugging
debug: $(TARGET)
	cmd /c start "" /max cmd /k "gdb -tui $(TARGET)"

# Clean up build artifacts
clean:
	del /q $(OBJ) $(TARGET) 2>nul || exit 0

# Phony targets
.PHONY: all run debug clean

